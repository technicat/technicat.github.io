---
layout: post
title: In Praise of State Machines
date: '2009-05-02T15:43:09-07:00'
tags: []
tumblr_url: https://fugugames.tumblr.com/post/110318350881/in-praise-of-state-machines
---
The state machine diagram is a highly underpromoted tool in game design. Often when I help out on a game project I ask for the state machine specification of the game. In one case, I was told, &ldquo;the game can go from any state to any state&rdquo;. Yes, that&rsquo;s true of general purpose programming languages (this was a programmer), and Turing Machines, but that doesn&rsquo;t help.

There is a specific technical definition of the state machine (more specifically, the finite state machine, in this case), which every programmer should know (although I somehow managed to avoid taking the course until grad school). But basically a finite state machine is a fixed set of states with transitions among them each of which is triggered by certain conditions.

Here&rsquo;s the FSM for a bowling game, showing init and game-end states, whether you&rsquo;re rolling the first or second ball in a frame, and so on.

<img class="alignnone size-medium wp-image-1981" title="img_1033" src="http://itshardtofondlepenguins.com/wp-content/uploads/2009/05/img_1033-300x225.jpg" alt="img_1033" width="300" height="225"/>

It could use a few more states to express special results like spares and strikes, and to implement the appropriate scoring rules. And the transitions should be labelled with their triggering conditions. The transitions are key - a set of powerpoint slider (or if you have art skills, a storyboard) does not sufficiently describe a game. I sat in on a design meeting for a military training simulation where there were plenty of slides but no specification for how you transitioned from one stage to another or back, whether there was a timeout, or mission accomplished, or what. Instead, they puttered around deciding where to put various props. This is the type of thing that bites you at the end of the game project - &ldquo;oh, we didn&rsquo;t think of that&rdquo;. Especially if the original designers are long gone, or if the project has taken so long you just can&rsquo;t remember what you had in mind.

If you can express the game as a state machine, you can visualize it, you can explain it, you can tweak it, and, bonus, you can code it. Time was, you&rsquo;d write up a huge game design bible, stow it away, have lots of meetings with programmers, and the programmers would guess up their own state machine in C++, perhaps using a state machine class from a Game Gems article. But more and more, designers are doing their own coding via game engine scripting languages, and some of them explicitly support state machines, e.g. Linden Scripting Language for Second Life (see the <a href="http://wiki.secondlife.com/">Second Life wiki</a>) and the Lua scripts used in CryEngine (see <a href="http://crymod.com/">CryMod</a>).

I&rsquo;m using <a href="http://unity3d.com/">Unity</a>, which doesn&rsquo;t have explicity state machine support in it&rsquo;s scripting (and many have noticed my minigames don&rsquo;t have much state - &ldquo;What&rsquo;s the point? Where&rsquo;s the scoring?&rdquo;), but I&rsquo;ve taken a couple of stabs at cobbling my own. Since each script has an Update function and can be activated and deactivated at will, at first I played with making a separate script for each state and transitioning among them by having one state/script disable itself and enable the next one. But that seemed rather bulky and involved a lot of manipulation in the game editor, so now I&rsquo;m trying a loop that calls a coroutine for each state, where each coroutine looks pretty much like a regular function but is responsible for setting the name of the next state/coroutine before it returns.
<blockquote>
<pre>var state:String;
function Start() { state="InitGame"; while (true) yield StartCoroutine(state); }</pre>
</blockquote>
This has the advantage of keeping the whole state machine in one script file and making it fairly clear which states transition to which. For example, the state/coroutine where the ball is actually rolling might look like this:
<blockquote>
<pre>     function BallRolling() {
       while (true) {
       if (GutterBall()) { state = "GutterBall"; break;}
       if (TimeOut()) { state = "OutOfTime"; break;}
       if (Quit()) { state = "InitGame"; break; }
       if (PinsDown()) { state = "ShowScore"; break; }
       yield();
       }
     }</pre>
</blockquote>
Each frame, this coroutine checks if there&rsquo;s an exit condition and specifies the next state, otherwise stays in this state.

Next article - &ldquo;In Praise of Whiteboards&rdquo;. Now that&rsquo;s a truly indispensable game design tool.
